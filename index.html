<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gensyn Ant Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
            position: relative;
        }
        
        #gensysText {
            position: fixed;
            left: 40px;
            top: 40px;
            font-size: 80px;
            font-weight: 900;
            color: white;
            opacity: 0.25;
            z-index: 20;
            pointer-events: none;
        }
        
        #gameTitle {
            color: #fff;
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            letter-spacing: 3px;
            z-index: 10;
        }
        
        #gameContainer {
            position: relative;
            z-index: 10;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 50%, #E0F6FF 100%);
            border: 6px solid #2c3e50;
            border-radius: 12px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            cursor: pointer;
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        #controlButtons {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .control-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #2c3e50;
            border-radius: 6px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        #scoreDisplay {
            color: #fff;
            font-size: 1.4em;
            margin-top: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            z-index: 10;
        }
        
        .score-row {
            display: inline-block;
            margin: 0 20px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            #gameTitle {
                font-size: 2em;
                margin-bottom: 15px;
            }
            #scoreDisplay {
                font-size: 1.1em;
            }
            .control-btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gensysText">GENSYN.AI</div>
    <div id="gameTitle">GENSYN ANT GAME</div>
    <div id="gameContainer">
        <div id="controlButtons">
            <button id="pauseBtn" class="control-btn">Pause</button>
            <button id="muteBtn" class="control-btn">Mute</button>
        </div>
        <canvas id="gameCanvas" width="900" height="300"></canvas>
    </div>
    <div id="scoreDisplay">
        <span class="score-row">Score: <span id="score">0</span></span>
        <span class="score-row">High Score: <span id="highScore">0</span></span>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 300;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // EMBEDDED GENSYN LOGO
        const gensynLogoData = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI0ZGNjZCMiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+RzwvdGV4dD48L3N2Zz4=';

        const gensynLogoImg = new Image();
        gensynLogoImg.src = gensynLogoData;
        let logoLoaded = false;

        gensynLogoImg.onload = () => {
            logoLoaded = true;
        };

        gensynLogoImg.onerror = () => {
            console.warn("Logo missing, using fallback");
        };

        // EMBEDDED AUDIO - Simple beep for hit sound
        const hitSoundData = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';
        const musicData = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';

        let hitSound = new Audio(hitSoundData);
        let bgMusic = new Audio(musicData);
        bgMusic.loop = true;
        
        let isMuted = false;
        let musicStarted = false;

        // CONFIG
        const CONFIG = {
            INITIAL_SPEED: 6,
            SPEED_RAMP_PER_SEC: 0.015,
            SCORE_SPEED_MULTIPLIER: 0.0008,
            MAX_GAME_SPEED: 14,
            SPAWN_BASE_MIN: 700,
            SPAWN_BASE_MAX: 1300,
            SPAWN_MIN_LIMIT: 350,
            SPAWN_DECREASE_FACTOR: 0.65,
            GRAVITY: 0.65,
            JUMP_STRENGTH: -13.5,
            OBSTACLE_BASE_SIZE: 35,
            OBSTACLE_MIN_SCALE: 0.9,
            OBSTACLE_MAX_SCALE: 1.15,
            SCORE_INCREMENT: 0.15,
            POINTS_PER_OBSTACLE: 15,
            GROUND_HEIGHT: 60,
            ANT_WIDTH: 110,
            ANT_HEIGHT: 130,
            ANT_RUN_FRAME_SPEED: 6,
            SINGLE_CHANCE: 0.75,
            DOUBLE_CHANCE: 0.20,
            FLYING_CHANCE: 0.05,
            DOUBLE_GAP_MIN: 70,
            DOUBLE_GAP_MAX: 120,
            FLYING_HEIGHT_MIN: 50,
            FLYING_HEIGHT_MAX: 100
        };

        // GAME STATE
        let gameState = 'start';
        let score = 0;
        let highScore = parseInt(localStorage.getItem('gensynAntHighScore')) || 0;
        let baseSpeed = CONFIG.INITIAL_SPEED;
        let isPaused = false;
        let lastSpeedUpdate = Date.now();
        let collisionParticles = [];
        let playerFlashTimer = 0;
        
        document.getElementById('highScore').textContent = highScore;

        // CONTROL BUTTONS
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('muteBtn').addEventListener('click', toggleMute);

        function togglePause() {
            if (gameState !== 'running') return;
            
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
            
            if (isPaused && !isMuted && musicStarted) {
                bgMusic.pause();
            } else if (!isPaused && !isMuted && musicStarted) {
                bgMusic.play().catch(() => {});
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            document.getElementById('muteBtn').textContent = isMuted ? 'Unmute' : 'Mute';
            
            if (isMuted) {
                bgMusic.pause();
                bgMusic.volume = 0;
                hitSound.volume = 0;
            } else {
                bgMusic.volume = 0.3;
                hitSound.volume = 0.5;
                if (gameState === 'running' && !isPaused && musicStarted) {
                    bgMusic.play().catch(() => {});
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyP') {
                e.preventDefault();
                togglePause();
            }
        });

        // DRAWING FUNCTIONS
        function drawAnt(x, y, width, height, frameIndex, isJumping) {
            ctx.save();
            
            if (playerFlashTimer > 0) {
                ctx.globalAlpha = (playerFlashTimer % 100 < 50) ? 0.3 : 1.0;
            }
            
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const bobOffset = isJumping ? 0 : Math.sin(frameIndex * Math.PI / 1.5) * 3;
            const rotation = isJumping ? -5 : (frameIndex - 1) * 2;
            
            ctx.translate(centerX, centerY + bobOffset);
            ctx.rotate((rotation * Math.PI) / 180);
            
            // Body
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.ellipse(0, 15, 22, 28, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Thorax
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(0, -5, 20, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.arc(0, -35, 22, 0, Math.PI * 2);
            ctx.fill();
            
            // Antennae
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-8, -45);
            ctx.lineTo(-18, -60);
            ctx.moveTo(8, -45);
            ctx.lineTo(18, -60);
            ctx.stroke();
            
            // Antenna tips
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(-18, -60, 4, 0, Math.PI * 2);
            ctx.arc(18, -60, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-8, -35, 4, 0, Math.PI * 2);
            ctx.arc(8, -35, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Legs
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            const legOffset = isJumping ? 0 : (frameIndex % 2) * 10;
            
            ctx.beginPath();
            ctx.moveTo(-15, -10);
            ctx.lineTo(-25 - legOffset, 10);
            ctx.moveTo(15, -10);
            ctx.lineTo(25 + legOffset, 10);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-18, 5);
            ctx.lineTo(-30 + legOffset, 25);
            ctx.moveTo(18, 5);
            ctx.lineTo(30 - legOffset, 25);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-15, 20);
            ctx.lineTo(-25 - legOffset, 40);
            ctx.moveTo(15, 20);
            ctx.lineTo(25 + legOffset, 40);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawBackgroundLogo() {
            if (!logoLoaded) return;
            
            const logoSize = 250;
            const x = (CANVAS_WIDTH - logoSize) / 2;
            const y = (CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - logoSize) / 2;
            
            ctx.save();
            ctx.globalAlpha = 0.10;
            ctx.drawImage(gensynLogoImg, x, y, logoSize, logoSize);
            ctx.restore();
        }

        // PARTICLES
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8 - 2;
                this.life = 100;
                this.maxLife = 100;
                this.size = Math.random() * 4 + 2;
                this.color = `hsl(${Math.random() * 60}, 100%, 50%)`;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3;
                this.life -= 3;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        function createCollisionParticles(x, y) {
            for (let i = 0; i < 15; i++) {
                collisionParticles.push(new Particle(x, y));
            }
        }

        // UTILS
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // PLAYER
        class Player {
            constructor() {
                this.width = CONFIG.ANT_WIDTH;
                this.height = CONFIG.ANT_HEIGHT;
                this.x = 120;
                this.groundY = CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
                this.y = this.groundY;
                this.velocityY = 0;
                this.isJumping = false;
                this.frameIndex = 0;
                this.frameTimer = 0;
                this.totalRunFrames = 3;
            }

            update() {
                if (isPaused) return;
                
                this.velocityY += CONFIG.GRAVITY;
                this.y += this.velocityY;

                if (this.y >= this.groundY) {
                    this.y = this.groundY;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                if (!this.isJumping && gameState === 'running') {
                    this.frameTimer++;
                    if (this.frameTimer >= CONFIG.ANT_RUN_FRAME_SPEED) {
                        this.frameTimer = 0;
                        this.frameIndex = (this.frameIndex + 1) % this.totalRunFrames;
                    }
                }
            }

            jump() {
                if (!this.isJumping && !isPaused) {
                    this.velocityY = CONFIG.JUMP_STRENGTH;
                    this.isJumping = true;
                }
            }

            draw() {
                drawAnt(this.x, this.y, this.width, this.height, this.frameIndex, this.isJumping);
            }

            getHitbox() {
                const padding = 20;
                return {
                    x: this.x + padding,
                    y: this.y + padding,
                    width: this.width - padding * 2,
                    height: this.height - padding * 2
                };
            }

            reset() {
                this.y = this.groundY;
                this.velocityY = 0;
                this.isJumping = false;
                this.frameIndex = 0;
                this.frameTimer = 0;
            }
        }

        // OBSTACLE
        class Obstacle {
            constructor(isFlying = false, xOffset = 0) {
                this.scale = randomFloat(CONFIG.OBSTACLE_MIN_SCALE, CONFIG.OBSTACLE_MAX_SCALE);
                this.width = CONFIG.OBSTACLE_BASE_SIZE * this.scale;
                this.height = CONFIG.OBSTACLE_BASE_SIZE * this.scale;
                
                this.x = CANVAS_WIDTH + 50 + xOffset;
                this.isFlying = isFlying;
                
                if (this.isFlying) {
                    this.y = CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height - 
                             randomInt(CONFIG.FLYING_HEIGHT_MIN, CONFIG.FLYING_HEIGHT_MAX);
                } else {
                    this.y = CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
                }
                
                this.markedForDeletion = false;
                this.passed = false;
            }

            update() {
                if (isPaused) return;
                
                this.x -= baseSpeed;

                if (this.x + this.width < 0) {
                    this.markedForDeletion = true;
                }

                if (!this.passed && this.x + this.width < player.x) {
                    this.passed = true;
                    score += CONFIG.POINTS_PER_OBSTACLE;
                }
            }

            draw() {
                if (logoLoaded) {
                    ctx.drawImage(gensynLogoImg, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = '#FF66B2';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            getHitbox() {
                const padding = 6;
                return {
                    x: this.x + padding,
                    y: this.y + padding,
                    width: this.width - padding * 2,
                    height: this.height - padding * 2
                };
            }
        }

        // CLOUD
        class Cloud {
            constructor() {
                this.x = randomInt(0, CANVAS_WIDTH);
                this.y = randomInt(20, 120);
                this.width = randomInt(60, 120);
                this.height = this.width * 0.6;
                this.speed = randomFloat(0.3, 0.8);
                this.opacity = randomFloat(0.3, 0.6);
            }

            update() {
                if (gameState === 'running' && !isPaused) {
                    this.x -= this.speed;
                    if (this.x + this.width < 0) {
                        this.x = CANVAS_WIDTH + 50;
                        this.y = randomInt(20, 120);
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width * 0.25, 0, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.3, this.y - this.height * 0.15, this.width * 0.35, 0, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.65, this.y, this.width * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // OBSTACLE SPAWNER with FIXED spawn interval calculation
        function computeNextSpawnInterval(currentScore) {
            const baseMin = CONFIG.SPAWN_BASE_MIN;
            const baseMax = CONFIG.SPAWN_BASE_MAX;
            const minLimit = CONFIG.SPAWN_MIN_LIMIT;
            const decrease = currentScore * CONFIG.SPAWN_DECREASE_FACTOR;
            
            let raw = Math.random() * (baseMax - baseMin) + baseMin;
            let adjusted = raw - decrease;
            
            if (adjusted < minLimit) adjusted = minLimit;
            
            return adjusted;
        }

        class ObstacleSpawner {
            constructor() {
                this.timer = 0;
                this.nextSpawnTime = computeNextSpawnInterval(0);
            }

            update(deltaTime) {
                if (gameState !== 'running' || isPaused) return;
                
                this.timer += deltaTime;
                
                if (this.timer >= this.nextSpawnTime) {
                    this.spawnObstacles();
                    this.timer = 0;
                    this.nextSpawnTime = computeNextSpawnInterval(score);
                }
            }

            spawnObstacles() {
                const rand = Math.random();
                
                if (rand < CONFIG.FLYING_CHANCE) {
                    obstacles.push(new Obstacle(true));
                } else if (rand < CONFIG.FLYING_CHANCE + CONFIG.DOUBLE_CHANCE) {
                    const gap = randomInt(CONFIG.DOUBLE_GAP_MIN, CONFIG.DOUBLE_GAP_MAX);
                    obstacles.push(new Obstacle(false, 0));
                    obstacles.push(new Obstacle(false, gap));
                } else {
                    obstacles.push(new Obstacle(false));
                }
            }

            reset() {
                this.timer = 0;
                this.nextSpawnTime = computeNextSpawnInterval(0);
            }
        }

        // INPUT
        class InputHandler {
            constructor() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.handleInput();
                    }
                });
                
                canvas.addEventListener('click', () => this.handleInput());
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleInput();
                });
            }

            handleInput() {
                if (gameState === 'start') {
                    game.start();
                } else if (gameState === 'running' && !isPaused) {
                    player.jump();
                } else if (gameState === 'running' && isPaused) {
                    togglePause();
                } else if (gameState === 'gameOver') {
                    game.restart();
                }
            }
        }

        // GAME MANAGER
        class Game {
            constructor() {
                this.lastTime = 0;
                this.clouds = [];
                for (let i = 0; i < 5; i++) {
                    this.clouds.push(new Cloud());
                }
            }

            start() {
                gameState = 'running';
                score = 0;
                baseSpeed = CONFIG.INITIAL_SPEED;
                lastSpeedUpdate = Date.now();
                isPaused = false;
                obstacles.length = 0;
                collisionParticles.length = 0;
                playerFlashTimer = 0;
                spawner.reset();
                player.reset();
                document.getElementById('pauseBtn').textContent = 'Pause';
                
                if (!isMuted && !musicStarted) {
                    musicStarted = true;
                    bgMusic.volume = 0.3;
                    bgMusic.play().catch(() => {});
                }
            }

            restart() {
                this.start();
            }

            updateSpeed() {
                if (isPaused) return;
                
                const now = Date.now();
                const deltaSeconds = (now - lastSpeedUpdate) / 1000;
                
                if (deltaSeconds >= 1) {
                    baseSpeed += CONFIG.SPEED_RAMP_PER_SEC;
                    baseSpeed += score * CONFIG.SCORE_SPEED_MULTIPLIER;
                    baseSpeed = Math.min(baseSpeed, CONFIG.MAX_GAME_SPEED);
                    lastSpeedUpdate = now;
                }
            }

            update(deltaTime) {
                this.clouds.forEach(cloud => cloud.update());
                
                collisionParticles.forEach((particle, index) => {
                    particle.update();
                    if (particle.isDead()) {
                        collisionParticles.splice(index, 1);
                    }
                });
                
                if (playerFlashTimer > 0) {
                    playerFlashTimer -= deltaTime;
                }
                
                if (gameState !== 'running' || isPaused) return;

                this.updateSpeed();
                player.update();
                spawner.update(deltaTime);

                obstacles.forEach((obstacle, index) => {
                    obstacle.update();
                    
                    if (checkCollision(player.getHitbox(), obstacle.getHitbox())) {
                        this.handleCollision(obstacle);
                    }
                    
                    if (obstacle.markedForDeletion) {
                        obstacles.splice(index, 1);
                    }
                });

                score += CONFIG.SCORE_INCREMENT;
                document.getElementById('score').textContent = Math.floor(score);
            }

            handleCollision(obstacle) {
                if (!isMuted) {
                    hitSound.currentTime = 0;
                    hitSound.volume = 0.5;
                    hitSound.play().catch(() => {});
                }
                
                const hitbox = player.getHitbox();
                createCollisionParticles(
                    hitbox.x + hitbox.width / 2,
                    hitbox.y + hitbox.height / 2
                );
                
                playerFlashTimer = 300;
                
                setTimeout(() => this.gameOver(), 300);
            }

            gameOver() {
                gameState = 'gameOver';
                
                if (!isMuted && musicStarted) {
                    bgMusic.pause();
                }

                if (score > highScore) {
                    highScore = Math.floor(score);
                    localStorage.setItem('gensynAntHighScore', highScore);
                    document.getElementById('highScore').textContent = highScore;
                }
            }

            drawGround() {
                const groundGradient = ctx.createLinearGradient(0, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT, 0, CANVAS_HEIGHT);
                groundGradient.addColorStop(0, '#228B22');
                groundGradient.addColorStop(1, '#1a6b1a');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT, CANVAS_WIDTH, CONFIG.GROUND_HEIGHT);

                ctx.strokeStyle = '#0d4d0d';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT);
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT);
                ctx.stroke();

                ctx.strokeStyle = '#2a9d2a';
                ctx.lineWidth = 2;
                for (let i = 0; i < CANVAS_WIDTH; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(i, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT);
                    ctx.lineTo(i + 5, CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 10);
                    ctx.stroke();
                }
            }

            drawUI() {
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`Score: ${Math.floor(score)}`, CANVAS_WIDTH - 20, 35);
                ctx.restore();

                if (gameState === 'start') {
                    this.drawMessage('Press SPACE or Tap to Start', '');
                } else if (gameState === 'gameOver') {
                    this.drawMessage('GAME OVER', `Final Score: ${Math.floor(score)} | Press SPACE or Tap to Restart`);
                } else if (isPaused) {
                    this.drawPausedOverlay();
                }
            }

            drawPausedOverlay() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Press P or click Resume to continue', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);
            }

            drawMessage(mainText, subText) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(mainText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
                if (subText) {
                    ctx.font = '22px Arial';
                    ctx.fillText(subText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
                }
            }

            draw() {
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                this.clouds.forEach(cloud => cloud.draw());
                drawBackgroundLogo();
                this.drawGround();
                obstacles.forEach(obstacle => obstacle.draw());
                collisionParticles.forEach(particle => particle.draw());
                player.draw();
                this.drawUI();
            }

            loop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(deltaTime);
                this.draw();
                requestAnimationFrame((t) => this.loop(t));
            }
        }

        // INITIALIZE
        const player = new Player();
        const obstacles = [];
        const spawner = new ObstacleSpawner();
        const inputHandler = new InputHandler();
        const game = new Game();

        function resizeCanvas() {
            const scale = Math.min((window.innerWidth - 40) / CANVAS_WIDTH, (window.innerHeight - 250) / CANVAS_HEIGHT, 1);
            canvas.style.width = (CANVAS_WIDTH * scale) + 'px';
            canvas.style.height = (CANVAS_HEIGHT * scale) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        game.loop(0);
    </script>
</body>
</html>
